1.请谈谈你对volatile的理解？
  volatile是java虚拟机提供的轻量级的同步机制
  保证可见性，不保证原子性，禁止指令重排
  JMM(Java Memory Model,JMM)内存模型，本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量
  （包括实例字段，静态字段和构成数组对象的元素）的访问方式，三大特性：可见性，原子性，有序性。
  JMM关于同步的规定：
  1.线程解锁前，必须把共享变量的值刷新回内存
  2.线程加锁前，必须读取主内存最新的值到自己的工作内存
  3.加锁解锁是用一把锁
  由于JVM运行内存的实体是线程，而每个线程创建的时候JVM都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有区域，而
  Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须
  在工作内存中进行，首先要将变量从主内存中拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存，不能
  直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间
  的通信（传值）必须通过主内存完成。

  保证可见性：保证当前线程一旦修改了从主内存拷贝过来的值后（此时值拷贝到了当前线程的私有内存），能够马上被其他拷贝了主内存的
             值的线程知道。（保证每个线程都能从主内存中取最新的值（该变量被volatile修饰））
             可见性的代码验证【VolatileDemo.java】
  不保证原子性：根据JMM的介绍，这就可能存在一个线程A修改了共享变量x的值但还未写回主内存时，例外一个线程BBB又对主内存中同一
               个共享变量x进行操作，但此时AAA线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象
               就造成了可见性问题。（即将数据取出来加一再塞回主内存这一个操作不是原子操作）
               什么是原子性？
               不可分割，完整性，也即某个线程正在做某个具体业务的时，中间不可以被加塞或者被分割，需要整体完整，
               要么同时成功，要么同时失败。
               如何解决原子性的问题？
                 1.synchronized
                 2.AtomicInteger
                   getAndIncrement() ===> Atomically increments by one the current value. 原子性的给当前值加1
  指令重排： 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致
            处理器在进行重排序时必需要考虑指令之间的数据依赖性
            多线程环境中线程交替进行，由于编译器优化重调的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测

  DCL（Double Check Lock双端检锁机制） 双重锁校验 【SingletonDemo】:运用到了volatile
